Group #3

Pat Duffil - U84513865
Kaijie Zhou - U54295267
Cathy Kim - U51788489

Database: 
We decided to use SQLite for our database because we thought that a relational database would make the most sense for a bank. We are able to use foreign keys to avoid repeating data and then furthermore query more easily through the data by understanding the relationships between the tables in the database. Moreover, we chose to use SQLite because this would make our project more portable and easy to work back and forth with. However, if this were an actual bank, we would have chosen a server based database because that would have been more scalable and allow access from anywhere rather than a local storage. We decided on the structure of the database by creating the UML diagram (attached png in project folder). 

Class Structure:
We began by determining the highest level elements (or classes) that make up a bank which were BankUsers and Accounts, which would act as abstract classes. Then, under BankUsers we would have the Customer and the BankManager classes as each class has different functionality (customer sees private information like their own accounts vs. the manager who has access to overviews of loans/customers/stocks/etc). The abstract bank users class allows inheritance of attributes/methods/constructors to subclasses in order to avoid repeated code and scalability for extending bank users to other types of users in the future (perhaps for example business owners). Next, for accounts we added our three types of accounts, checking, saving and securities. At this point, we considered how we would represent the characteristic of being “transactable” in the sense that we want to withdraw and deposit money into these accounts as these were a common trait the accounts would need. At this point, we determined that due to the restrictive nature of the relationship between the savings bank and the securities bank for amounts of money present in the accounts, we decided that it would make the most sense that the withdraw/deposit functionality only be given to the savings and checking accounts and that the securities account can only gain/lose money by transferring via the savings account or buying/selling stocks. Because multiple classes under accounts had certain qualities but not all of them, we decided that transactions should be an interface. Furthermore, from the securities bank, we decided to create object classes to represent stocks and the stock market. Next, to expand the customer’s abilities, we created loans and collateral object classes in which the customer can try and “apply” for a loan (gets rejected/accepts by manager). For simplicity of the assignment, we simply took any collateral the customer inputted and assumed that equaled to the amount of the loan and attach to the “application” or request of a loan and moreover there is a dependency on the manager himself to approve/reject so he can determine if the collateral is actually worth giving the loan (also assumed the bank has unlimited amount of money and that the manager himself can determine whether he wants to give out large loans). Ideally, there would be some way of checking the collateral and it's worth more automatically than the manager himself discerning this himself, however such a system would be pretty complex and out of scope for this project. Finally, we implemented currency objects (USD, Canadian, Australian, Pounds, and Euro subclasses to the abstract Currency), each with their own exchange rates (only the manager is allowed to change the exchange rate at his own will), although interally everything remains in dollars. (A small note, we assumed that the bank is based in America and the bank is internally saved as dollars.) This allowed an encapsulation of info within each currency and all the front end does is simply input the desired currency change into a function and the currency converter class will do all of this adding a layer of abstraction. Other OOD principles used, many subclasses use keyword super for reusable constructors and scalability to add many other varieties of subclasses, any set variables given in the assignment sheet (e.g. minimum transfer amount from securities must be 1,000 or need minimum of 2,500 in securities) are set to one variable and that variable is called on so this allows for changes to these rules to be easily updated sort of adding a level of encapsulation to many of the methods. We kept everything as hierarchically organized into abstract extendible superclasses with extendible subclasses as much as possible such that any types of additions to the bank may find a class to extend for many traits and thus scalable. We utilized the different advantages between abstract classes and interfaces. All variables are protected/private with getter/setter methods. We utilized static variables/methods in times when a certain attribute/corresponding method does not depend on an instance. 

Front end:
In general, we followed the idea where the front end code simply has the objects to be displayed in front of the user in a window and functionality would simply call a method within the classes to maintain abstraction. Then, within the class method we would have calls to the database. We chose to follow this in order to demonstrate proper abstraction such that the front end will never have to “worry” about or communicate with the database and simply call the object and method necessary and trust that the backend does everything correctly. In general, for any action we created a physical corresponding button and a page to represent relationships between functionality or transitions between functions.

Front end class Structure: We chose to make almost every “function” of the bank its own JFrame window. This was because whenever someone does an action in the bank, we need to make a database call and typically edit the contents of the database, and the user has to open up the page again from their main menu in order for the data to refresh. Due to the time constraints of learning Java Swing, we considered learning how to refresh the pages on their own but found the process to be too time consuming and would lead to hold ups in progress, even though the constant database calls could end up being slower if this application would be scaled up more. The UI is not the prettiest, but we focused on creating buttons and windows that function how they should due to the scale of the project.
